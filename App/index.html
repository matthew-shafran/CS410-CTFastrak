<!DOCTYPE html>
<html>
    <head>
    	<style>
   			 #map { position: relative;
   			 			
   			 			}
  			 #overMap { position: absolute; top: 50px; left: 10px; z-index: 99; width:200px; 
  			 height:200px; background:white; border-style: solid; border-width: 5px;
  			 border-color: green }
		</style>
        <title>CTFastrak CS410</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="css/style.css"> 
  </head>
  <body onload="initSearch()">
    	<div id="map"></div>
    	
    	<div id="overMap">
    		<center><h3>Show / Hide</h3>
    		<hr>
    		<table>
    		<form action="toggleMarkers()" method="get">
    			<tr><td>Routes:&nbsp;</td>
    			<td><input type="checkbox" name="route" value="route"></td></tr>
    			<tr><td>Stops:&nbsp;</td>
    			<td><input type="checkbox" name="stop" value="stop"></td></tr>
    			<tr><td>Buses:&nbsp;</td>
    			<td><input type="checkbox" name="bus" value="bus"></td></tr>
    		</form>
    		</table>
    		</center>
    	</div>
    	
    	
    	<input id="origin-input" class="controls" type="text"
        	placeholder="Enter an origin location">

    	<input id="destination-input" class="controls" type="text"
        	placeholder="Enter a destination location">
        	
        
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js"></script>        
        <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB1lGcwF1Oe-mDyhYW9oWWscAYoc5T-c7A&libraries=places&callback=MapInterface.init" async defer></script>
        <script src="js/map.js"></script>
        <script type="text/javascript">
         function initSearch(){
        	var origin_place_id = null;
  			var destination_place_id = null;
  			var travel_mode = google.maps.TravelMode.WALKING;
  			var directionsService = new google.maps.DirectionsService;
		  	var directionsDisplay = new google.maps.DirectionsRenderer;
		  	var map = MapInterface.map;
		  	directionsDisplay.setMap(map);
		  	
		  		var terminals = MapInterface.busterminals;
		  	var propValue;

			for(var propName in terminals) {
    			propValue = terminals[propName]

   				 //console.log(propName, propValue);
			}


			var origin_input = document.getElementById('origin-input');
			var destination_input = document.getElementById('destination-input');
		  	var modes = document.getElementById('mode-selector');
	
			map.controls[google.maps.ControlPosition.TOP_LEFT].push(origin_input);
			map.controls[google.maps.ControlPosition.TOP_LEFT].push(destination_input);

		  	var origin_autocomplete = new google.maps.places.Autocomplete(origin_input);
		 	origin_autocomplete.bindTo('bounds', map);
			var destination_autocomplete =
			new google.maps.places.Autocomplete(destination_input);
		  destination_autocomplete.bindTo('bounds', map);

		  function expandViewportToFitPlace(map, place) {
			if (place.geometry.viewport) {
			  map.fitBounds(place.geometry.viewport);
			} else {
			  map.setCenter(place.geometry.location);
			  map.setZoom(17);
			}
		  }

		  origin_autocomplete.addListener('place_changed', function() {
			var place = origin_autocomplete.getPlace();
			if (!place.geometry) {
			  window.alert("Autocomplete's returned place contains no geometry");
			  return;
			}
			expandViewportToFitPlace(map, place);

			// If the place has a geometry, store its place ID and route if we have
			// the other place ID
			origin_place_id = place.place_id;
			route(origin_place_id, destination_place_id, travel_mode,
				  directionsService, directionsDisplay);
		  });

		  destination_autocomplete.addListener('place_changed', function() {
			var place = destination_autocomplete.getPlace();
			if (!place.geometry) {
			  window.alert("Autocomplete's returned place contains no geometry");
			  return;
			}
			expandViewportToFitPlace(map, place);

			// If the place has a geometry, store its place ID and route if we have
			// the other place ID
			destination_place_id = place.place_id;
			route(origin_place_id, destination_place_id, travel_mode,
				  directionsService, directionsDisplay);
		  });

		  function route(origin_place_id, destination_place_id, travel_mode,
						 directionsService, directionsDisplay) {
			if (!origin_place_id || !destination_place_id) {
			  return;
			}
			directionsService.route({
			  origin: {'placeId': origin_place_id},
			  destination: {'placeId': destination_place_id},
			  travelMode: travel_mode
			}, function(response, status) {
			  if (status === google.maps.DirectionsStatus.OK) {
				directionsDisplay.setDirections(response);
				var originCoordinates = convertAddress(document.getElementById("origin-input").value);
				var originLatitude = originCoordinates[0];
				var originLongitude = originCoordinates[1];
				var stops = getNearbyStops(originLatitude, originLongitude);
				
				var distanceMatrixAPICall = "https://maps.googleapis.com/maps/api/distancematrix/json?origins=";
				distanceMatrixAPICall += originLatitude + ",";
				distanceMatrixAPICall += originLongitude + "&destinations=";
				for(var stop in stops){
					distanceMatrixAPICall += stop.stopLatitude + ",";
					distanceMatrixAPICall += stop.stopLongitude + "|"; //seems okay to have an extra | even on the last set of coordinates
				}
				
				distanceMatrixAPICall += "&mode=walking&units=metric&key=AIzaSyDnGdU7F4vK16j0ISHJn4Y7oS1eTg4-Qng";
				//<script src="distanceMatrixAPICall"> --- i think just doing a script call like this will call the API and get json data back. 
				
				
				
				var numOfShortest = findShortestPathToStop(json); //not sure what the response will be called, so just calling it json for now
				
				stops[numOfShortest]; // This should be the bus stop with the shortest path. Can get longitude / latitude or id to place it on map.
						
				
				
				
			  } else {
				window.alert('Directions request failed due to ' + status);
			  }
    	});
    	}
  	}
  	
  	//Converts a given address into its' coordinates.
  	function convertAddress( address ) {
  		var geocoder = new google.maps.Geocoder();
	  	geocoder.geocode( { 
			'address' : address 
	  	}, function(results, status) {
				if ( status == google.maps.GeocoderStatus.OK ) {
		  			return [results[0].geometry.location.lat(), results[0].geometry.location.lng()];
				} else alert("Geocode failed, status: "+status);
	  		});
	}
	
	//Takes two pairs of coordinates and compares their distance (in km).
	function computeDistance(lat1, lon1, lat2, lon2) {
  		var p = 0.017453292519943295;    // Math.PI / 180
  		var c = Math.cos;
  		var a = 0.5 - c((lat2 - lat1) * p)/2 + 
          c(lat1 * p) * c(lat2 * p) * 
          (1 - c((lon2 - lon1) * p))/2;

  		return 12742 * Math.asin(Math.sqrt(a)); // 2 * R; R = 6371 km
	}
	
	//Finds stops within "searchDistance" km's of the origin point.
	function getNearbyStops(originLatitude, originLongitude){
		var terminals = MapInterface.busterminals;
		var propValue;
		var stopLatitude;
		var stopLongitude;
		var closestStop = {distance: 1000000,
							id: 0}; // Keeping track of the closest stop just in case no stops are within the specified distance.
		var searchDistance = 200; // Distance in which to search for bus stops.
		var nearbyStops = [];
		for(var propName in terminals) {
			propValue = terminals[propName]
			stopLatitude = propValue.stop_lat;
			stopLongitude = propValue.stop_lon;
			var distance = computeDistance(originLatitude, originLongitude, stopLatitude, stopLongitude);
			if(distance < closestStop.distance){
				closestStop.distance = distance;
				closestStop.id = propValue.id;
			}
			if(distance <= searchDistance)
				nearbyStops.push({ stopID: 			propValue.stop_id,
								   stopLongitude: 	stopLongitude,
								   stopLatitude:	stopLatitude,	
				})		
		}
		
		if(nearbyStops.length == 0)
			return closestStop;
		else
			return nearbyStops;
	}
	
	
	//Find the shortest path (walking distance) from the origin to bus stop
	//
	//Keeping track of distance and time because minutes is the smallest unit, so multiple
	//	destinations may have the same time but different distances
	function findShortestPathToStop(json){
		var shortest = {time: 1000000,
						distance: 100000}
		var stops = json.rows.elements;
		var time;
		var count = 0;
		var countShortest = 0;
		
		for(var stop in stops){
			var min =convertTime(stop.duration.text);
			if(min < shortest.time || (min == shortest.time && parseInt.stop.distance.value < shortest.distance)){
				shortest.time = min;
				shortest.distance = parseInt(stop.distance.value);	
				countShortest = count;
			}
			count++;
		}	
		return countShortest;
	
	}
	
	//Converts a string of days, hours, and/or minutes to minutes.
	function convertTime(timeString){
		var split = timeString.split(" ");
		var minutes = 0;
	
		for(var i =0; i <= (split.length/2); i+=2){
			var num = parseInt(split[i]);
			if(split[i+1] == "hour" || split[i+1] == "hours")
				minutes += (num * 60);	
			else if(split[i+1] == "min" || split[i+1] == "mins")
				minutes += num; 			
			else if(split[i+1] == "day" || split[i+1] == "days")
				minutes += (num * 60 * 24);
		}
		return minutes;
}
	
	
</script>
            
      <!--  <button onclick="centerMap()">Center Map</button> -->
    </body>
</html>

